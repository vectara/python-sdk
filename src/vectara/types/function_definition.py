# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .execution_configuration import ExecutionConfiguration
from .function_definition_validation_status import FunctionDefinitionValidationStatus


class FunctionDefinition(UniversalBaseModel):
    """
    Definition of a function to be executed as a tool in a sandboxed environment.

    **Python Environment:**
    - Python version: 3.12
    - Execution: Sandboxed using gVisor for security isolation
    - **Allowed modules**: `json`, `math`, `datetime`, `collections`, `itertools`, `functools`, `re`, `time`, `typing`
    - Memory limit: 100MB (configurable up to 1GB)
    - Execution timeout: 30 seconds (configurable up to 300 seconds)
    - Network access: Disabled for security
    - File system access: Read-only temporary workspace
    - No custom package installation supported (security constraint)

    **Type Annotations:**
    - Use type annotations for automatic input/output schema discovery
    - Supported typing constructs: `List`, `Dict`, `Optional`, `Union`
    - Import from `typing` module when using complex types
    """

    language: typing.Literal["python"] = pydantic.Field(default="python")
    """
    The programming language of the function. Currently only Python 3.12 is supported.
    """

    code: str = pydantic.Field()
    """
    The function code.
    
    **Required**: Must define a `process()` entry point function. Use type annotations on parameters for automatic schema discovery.
    
    Parameters are passed as keyword arguments matched to the function signature.
    """

    validation_status: typing.Optional[FunctionDefinitionValidationStatus] = pydantic.Field(default=None)
    """
    The validation status of the code.
    """

    validation_errors: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of validation errors if the code is invalid.
    """

    execution_configuration: typing.Optional[ExecutionConfiguration] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
