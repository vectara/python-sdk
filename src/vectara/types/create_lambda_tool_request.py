# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from .execution_configuration import ExecutionConfiguration


class CreateLambdaToolRequest(UniversalBaseModel):
    """
    Request to create a new lambda tool. Lambda tools are user-defined functions that run
    in a secure, sandboxed environment with Python 3.12.

    Input and output schemas are automatically discovered from function parameter type annotations in your code.
    """

    type: typing.Literal["lambda"] = "lambda"
    name: str = pydantic.Field()
    """
    The unique name of the tool (used as the function identifier).
    """

    title: str = pydantic.Field()
    """
    Human-readable title of the tool displayed in the UI.
    """

    description: str = pydantic.Field()
    """
    A detailed description of what the function does, when to use it, and what it returns.
    """

    language: typing.Optional[typing.Literal["python"]] = pydantic.Field(default=None)
    """
    The programming language. Currently only 'python' (Python 3.12) is supported.
    """

    code: str = pydantic.Field()
    """
    The Python 3.12 code for the function.
    
    **Required**: Must define a `process()` entry point function. Use type annotations on parameters for automatic schema discovery.
    
    **Parameters**: Passed as keyword arguments matched to the function signature.
    
    **Return types**: Can return any JSON-serializable type (strings, numbers, booleans, lists, or objects).
    
    **Example: Returning a number**
    ```python
    def process(x: int, y: int) -> int:
        return x + y
    ```
    
    **Example: Returning a string**
    ```python
    def process(name: str) -> str:
        return f"Hello, {name}!"
    ```
    
    **Example: Returning a boolean**
    ```python
    def process(value: int, threshold: int) -> bool:
        return value > threshold
    ```
    
    **Example: Returning a list**
    ```python
    from typing import List
    
    def process(items: List[str]) -> List[str]:
        return sorted(items)
    ```
    
    **Example: Returning an object (dict)**
    ```python
    def process(order_count: int, total_revenue: float, days_active: int = 1) -> dict:
        score = (order_count * 10 + total_revenue * 0.1) / days_active
        return {'score': round(score, 2), 'rating': 'high' if score > 100 else 'low'}
    ```
    
    For complex types, use the `typing` module:
    
    ```python
    from typing import List, Dict
    
    def process(items: List[str], config: Dict[str, float]) -> dict:
        count = len(items)
        multiplier = config.get('multiplier', 1.0)
        return {'count': count, 'adjusted': count * multiplier}
    ```
    """

    execution_configuration: typing.Optional[ExecutionConfiguration] = None

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
